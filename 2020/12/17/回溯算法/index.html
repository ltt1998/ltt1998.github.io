<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>回溯算法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="回溯算法一、回溯算法框架解决一个问题，实际上就是一个决策树的遍历过程。**只需要思考三个问题： 1、路径：也就是已经做出的选择 2、选择列表：也就是当前可以做的选择 3、结束条件：也就是到达决策树底层，无法再做选择的条件。 12345678910result &#x3D; []def backtrack(路径, 选择列表):    if 满足结束条件:        result.add(路径)">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯算法">
<meta property="og:url" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="回溯算法一、回溯算法框架解决一个问题，实际上就是一个决策树的遍历过程。**只需要思考三个问题： 1、路径：也就是已经做出的选择 2、选择列表：也就是当前可以做的选择 3、结束条件：也就是到达决策树底层，无法再做选择的条件。 12345678910result &#x3D; []def backtrack(路径, 选择列表):    if 满足结束条件:        result.add(路径)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20201217161924144.png">
<meta property="og:image" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20201217162247832.png">
<meta property="og:image" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220111321849.png">
<meta property="og:image" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220113023744.png">
<meta property="og:image" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220114521011.png">
<meta property="og:image" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220133318512.png">
<meta property="article:published_time" content="2020-12-17T02:53:10.000Z">
<meta property="article:modified_time" content="2021-02-23T13:14:42.144Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20201217161924144.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ltt1998.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-回溯算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-12-17T02:53:10.000Z" itemprop="datePublished">2020-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      回溯算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="一、回溯算法框架"><a href="#一、回溯算法框架" class="headerlink" title="一、回溯算法框架"></a>一、回溯算法框架</h3><p>解决一个问题，实际上就是一个决策树的遍历过程。**只需要思考三个问题：</p>
<p>1、路径：也就是已经做出的选择</p>
<p>2、选择列表：也就是当前可以做的选择</p>
<p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>其核心就是for循环里面的递归，在<strong>递归之前做选择</strong>，在<strong>递归调用之后撤销选择</strong></p>
<h4 id="1、全排列问题"><a href="#1、全排列问题" class="headerlink" title="1、全排列问题"></a>1、全排列问题</h4><p>n个不重复的数，全排列共有n！个。</p>
<p>可把回溯树称为回溯算法的【决策树】，因为在每个节点上都在做决策</p>
<p>可以把【路径】和【选择】列表作为决策树上每个节点的属性。</p>
<p>定义的backtrack函数就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其【路径】就是一个全排列。</p>
<p>各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.childern)</span><br><span class="line">        // 前序遍历需要的操作</span><br><span class="line">        traverse(child);</span><br><span class="line">        // 后序遍历需要的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20201217161924144.png" alt="image-20201217161924144"></p>
<p>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。</p>
<p><img src="/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20201217162247832.png" alt="image-20201217162247832"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>

<p><strong>在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确的到每个节点的选择列表和路径。</p>
<p>看下面的全排列代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">    // 记录「路径」</span><br><span class="line">    LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 路径：记录在 track 中</span><br><span class="line">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="line">// 结束条件：nums 中的元素全都在 track 中出现</span><br><span class="line">void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) &#123;</span><br><span class="line">    // 触发结束条件</span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(new LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 排除不合法的选择</span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        // 进入下一层决策树</span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        // 取消选择</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯算法的特点：不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p>
<h4 id="2、N皇后问题"><a href="#2、N皇后问题" class="headerlink" title="2、N皇后问题"></a>2、N皇后问题</h4><p>给一个N×N的棋盘，让放置N个皇后，使得它们不能互相攻击。</p>
<p>PS:皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p>
<p>N皇后问题本质跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">/* 输入棋盘边长 n，返回所有合法的放置 */</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">    // <span class="string">&#x27;.&#x27;</span> 表示空，<span class="string">&#x27;Q&#x27;</span> 表示皇后，初始化空棋盘。</span><br><span class="line">    vector&lt;string&gt; board(n, string(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span><br><span class="line">// 选择列表：第 row 行的所有列都是放置皇后的选择</span><br><span class="line">// 结束条件：row 超过 board 的最后一行</span><br><span class="line">void backtrack(vector&lt;string&gt;&amp; board, int row) &#123;</span><br><span class="line">    // 触发结束条件</span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = board[row].size();</span><br><span class="line">    <span class="keyword">for</span> (int col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        // 排除不合法选择</span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        // 做选择</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        // 进入下一行决策</span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        // 撤销选择</span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isValid的函数实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 是否可以在 board[row][col] 放置皇后？ */</span><br><span class="line">bool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123;</span><br><span class="line">    int n = board.size();</span><br><span class="line">    // 检查列是否有皇后互相冲突</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查右上方是否有皇后互相冲突</span><br><span class="line">    <span class="keyword">for</span> (int i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检查左上方是否有皇后互相冲突</span><br><span class="line">    <span class="keyword">for</span> (int i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数backtrack依旧像个在决策树上游走的指针，通过row和col就可以表示函数遍历到的位置，通过isValid函数可以将不符合条件的情况剪枝。</p>
<p><strong>有时候，并不想得到所有合法的答案，只想要一个答案。</strong>修改如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/ 函数找到一个答案后就返回 true</span><br><span class="line">bool backtrack(vector&lt;string&gt;&amp; board, int row) &#123;</span><br><span class="line">    // 触发结束条件</span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (int col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backtrack(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line"></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p>回溯算法就是个多叉树的遍历问题。</p>
<p>写backtrack函数时，需要维护走过的【路径】和当前可以做的【选择列表】，当触发【结束条件】时，将【路径】计入结果集。</p>
<p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。</p>
<h3 id="二、团灭排列-组合-子集等问题"><a href="#二、团灭排列-组合-子集等问题" class="headerlink" title="二、团灭排列/组合/子集等问题"></a>二、团灭排列/组合/子集等问题</h3><h4 id="1、子集"><a href="#1、子集" class="headerlink" title="1、子集"></a>1、子集</h4><p>问题：输入一个不包含重复数字的数组，要求输出这些数字的所有子集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums);</span><br></pre></td></tr></table></figure>

<p>比如输入nums=[1，2，3]，算法应输出8个子集，包括空集和本身，顺序可不同。</p>
<p>[ [],[1],[2],[3],[1,3],[2,3],[1,2],[1,2,3] ]</p>
<p><strong>第一个解法是利用数学归纳的思想：</strong>假设知道了规模更小的子问题的结果，如何推导出当前问题的结果？</p>
<p><img src="/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220111321849.png" alt="image-20210220111321849"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    // base case，返回一个空集</span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    // 把最后一个元素拿出来</span><br><span class="line">    int n = nums.back();</span><br><span class="line">    nums.pop_back();</span><br><span class="line">    // 先递归算出前面元素的所有子集</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res = subsets(nums);</span><br><span class="line"></span><br><span class="line">    int size = res.size();</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        // 然后在之前的结果之上追加</span><br><span class="line">        res.push_back(res[i]);</span><br><span class="line">        res.back().push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是时间复杂度比较容易坑人。</strong>以前讲过的计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数。对于这个问题，递归深度显然是N，但是每次递归for循环的迭代次数取决于res的长度，并不是固定的。</p>
<p>根据这个思路，res的长度应该是每次递归都翻倍，所以说总的迭代次数是2^n。或者可以直接思考一个大小为n的子集共有多少个，2^n个，所以至少要对res添加2^n次元素。</p>
<p>那么算法的时间复杂度是O（2^n）吗？不对。2^n个子集是push_back添加进res的，所以要考虑push_back这个操作的效率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; res = ...</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    res.push_back(res[i]); // O(N)</span><br><span class="line">    res.back().push_back(n); // O(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为res[i]也是一个数组，push_back是把res[i]复制一份添加进数组，所以一次操作的时间是O（n）。</p>
<p>综上所述，总的时间复杂度就是O（n*2^n）。</p>
<p>空间复杂度的话，如果不计算存储返回结果所用的空间的话，只需要O（n）的递归堆栈空间。如果计算res所需空间，应该是O（n*2^n）。</p>
<p><strong>第二种通用方法就是回溯算法。</strong></p>
<p>改造回溯算法的模板即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    // 记录走过的路径</span><br><span class="line">    vector&lt;int&gt; track;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; track) &#123;</span><br><span class="line">    res.push_back(track);</span><br><span class="line">    // 注意 i 从 start 开始递增</span><br><span class="line">    <span class="keyword">for</span> (int i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.push_back(nums[i]);</span><br><span class="line">        // 回溯</span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        // 撤销选择</span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把对res的更新看作一个前序遍历，res就是树上的所有节点。</p>
<p><img src="/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220113023744.png" alt="image-20210220113023744"></p>
<h4 id="2、组合"><a href="#2、组合" class="headerlink" title="2、组合"></a>2、组合</h4><p>输入两个数字n，k，算法输出【1…n】中k个数字的所有组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; combine(int n, int k);</span><br></pre></td></tr></table></figure>

<p>比如输入n=4，k=2，输入如下结果，顺序无所谓，但是不能包含重复（按照组合的定义，【1，2】和【2，1】也算重复）：</p>
<p>[ [1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]</p>
<p>这就是典型的回溯算法，k限制了树的高度，n限制了树的宽度。直接套回溯模板即可。</p>
<p><img src="/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220114521011.png" alt="image-20210220114521011"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt;res;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;int&gt; track;</span><br><span class="line">    backtrack(n, k, <span class="number">1</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(int n, int k, int start, vector&lt;int&gt;&amp; track) &#123;</span><br><span class="line">    // 到达树的底部</span><br><span class="line">    <span class="keyword">if</span> (k == track.size()) &#123;</span><br><span class="line">        res.push_back(track);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 注意 i 从 start 开始递增</span><br><span class="line">    <span class="keyword">for</span> (int i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.push_back(i);</span><br><span class="line">        backtrack(n, k, i + <span class="number">1</span>, track);</span><br><span class="line">        // 撤销选择</span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>backtrack函数和计算子集的差不多。<strong>区别是，更新res的地方是树的底端。</strong></p>
<h4 id="3、排列"><a href="#3、排列" class="headerlink" title="3、排列"></a>3、排列</h4><p>输入一个不包含重复数字的数组 <code>nums</code>，返回这些数字的全部排列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums);</span><br></pre></td></tr></table></figure>

<p>比如说输入数组 <code>[1,2,3]</code>，输出结果应该如下，顺序无所谓，不能有重复：</p>
<p>[<br> [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]<br>]</p>
<p><img src="/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210220133318512.png" alt="image-20210220133318512"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排列问题的树比较对称，而组合问题的树越靠右节点越少。</p>
<p>在代码中的体现就是，排列问题每次通过contains方法来排除track中已经选择过的数字；而组合问题通过传入一个start参数，来排除start索引之前的数字。</p>
<h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h4><p>子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以使用回溯算法，要用start参数排除已选择的数字。</p>
<p>组合问题利用的是回溯思想，结果可以表示成树结构，只要套用模板即可，关键点在于要用一个start排除已经选择过的数字。</p>
<p>排列问题就是回溯思想，也可以表示成树结构套用算法模板，不同之处在于使用contains方法排除已经选择的数字。</p>
<h3 id="三、解数独"><a href="#三、解数独" class="headerlink" title="三、解数独"></a>三、解数独</h3><p><strong>算法的核心思路非常非常的简单，就是对每一个空着的格子穷举 1 到 9，如果遇到不合法的数字（在同一行或同一列或同一个 3×3 的区域中存在相同的数字）则跳过，如果找到一个合法的数字，则继续穷举下一个空格子</strong>。</p>
<h4 id="1、代码实现"><a href="#1、代码实现" class="headerlink" title="1、代码实现"></a>1、代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void solveSudoku(char[][] board);</span><br></pre></td></tr></table></figure>

<p>根据回溯算法对每一个格子进行穷举，可写出大致的代码框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void solveSudoku(char[][] board) &#123;</span><br><span class="line">    backtrack(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(char[][] board, int r, int c) &#123;</span><br><span class="line">    int m = <span class="number">9</span>, n = <span class="number">9</span>;</span><br><span class="line">    // 就是对棋盘的每个位置进行穷举</span><br><span class="line">    <span class="keyword">for</span> (int i = r; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = c; j &lt; n; j++) &#123;</span><br><span class="line">            // 做选择</span><br><span class="line">            backtrack(board, i, j);</span><br><span class="line">            // 撤销选择</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何穷举呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(char[][] board, int r, int c) &#123;</span><br><span class="line">    int m = <span class="number">9</span>, n = <span class="number">9</span>;</span><br><span class="line">    // 就是对每个位置进行穷举</span><br><span class="line">    <span class="keyword">for</span> (int i = r; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = c; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (char ch = <span class="string">&#x27;1&#x27;</span>; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch++) &#123;</span><br><span class="line">                // 做选择</span><br><span class="line">                board[i][j] = ch;</span><br><span class="line">                // 继续穷举下一个</span><br><span class="line">                backtrack(board, i, j + <span class="number">1</span>);</span><br><span class="line">                // 撤销选择</span><br><span class="line">                board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续细化，并不是1到9都可以取到，因为有的数字不能满足数据的合法条件。而且现在只是给j加一，如果j加到最后一列了呢？</p>
<p><strong>当j到达超过最后一个索引时，转为增加i开始穷举下一行，并且在穷举之前添加一个判断，跳过不满足条件的数字：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(char[][] board, int r, int c) &#123;</span><br><span class="line">    int m = <span class="number">9</span>, n = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == n) &#123;</span><br><span class="line">        // 穷举到最后一列的话就换到下一行重新开始。</span><br><span class="line">        backtrack(board, r + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 就是对每个位置进行穷举</span><br><span class="line">    <span class="keyword">for</span> (int i = r; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = c; j &lt; n; j++) &#123;</span><br><span class="line">            // 如果该位置是预设的数字，不用我们操心</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                backtrack(board, i, j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (char ch = <span class="string">&#x27;1&#x27;</span>; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch++) &#123;</span><br><span class="line">                // 如果遇到不合法的数字，就跳过</span><br><span class="line">                <span class="keyword">if</span> (!isValid(board, i, j, ch))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                board[i][j] = ch;</span><br><span class="line">                backtrack(board, i, j + <span class="number">1</span>);</span><br><span class="line">                board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断 board[i][j] 是否可以填入 n</span><br><span class="line">boolean isValid(char[][] board, int r, int c, char n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        // 判断行是否存在重复</span><br><span class="line">        <span class="keyword">if</span> (board[r][i] == n) <span class="keyword">return</span> false;</span><br><span class="line">        // 判断列是否存在重复</span><br><span class="line">        <span class="keyword">if</span> (board[i][c] == n) <span class="keyword">return</span> false;</span><br><span class="line">        // 判断 <span class="number">3</span> x <span class="number">3</span> 方框是否存在重复</span><br><span class="line">        <span class="keyword">if</span> (board[(r/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>][(c/<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == n)</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候结束递归？显然r=m的时候就说明琼剧完了最后一行，完成了所有的穷举，就是base case。</p>
<p>为了减小复杂度，我们还可以让backtrack函数返回值为boolean，如果找到一个可行解就返回true，这样就可以阻止后续的递归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">boolean backtrack(char[][] board, int r, int c) &#123;</span><br><span class="line">    int m = <span class="number">9</span>, n = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == n) &#123;</span><br><span class="line">        // 穷举到最后一列的话就换到下一行重新开始。</span><br><span class="line">        <span class="keyword">return</span> backtrack(board, r + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == m) &#123;</span><br><span class="line">        // 找到一个可行解，触发 base case</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 就是对每个位置进行穷举</span><br><span class="line">    <span class="keyword">for</span> (int i = r; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = c; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                // 如果有预设数字，不用我们穷举</span><br><span class="line">                <span class="keyword">return</span> backtrack(board, i, j + <span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (char ch = <span class="string">&#x27;1&#x27;</span>; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch++) &#123;</span><br><span class="line">                // 如果遇到不合法的数字，就跳过</span><br><span class="line">                <span class="keyword">if</span> (!isValid(board, i, j, ch))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                board[i][j] = ch;</span><br><span class="line">                // 如果找到一个可行解，立即结束</span><br><span class="line">                <span class="keyword">if</span> (backtrack(board, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> true;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            // 穷举完 <span class="number">1</span>~<span class="number">9</span>，依然没有找到可行解，此路不通</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean isValid(char[][] board, int r, int c, char n) &#123;</span><br><span class="line">    // 见上文</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、算法可视化"><a href="#2、算法可视化" class="headerlink" title="2、算法可视化"></a>2、算法可视化</h4><p>让算法帮忙玩游戏的核心是算法，如果理解了这个算法，剩下就是借助安卓脚本引擎Auto.js调用API操作手机了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void setNum(Button b, char n) &#123;</span><br><span class="line">    // 输入一个方格，将该方格设置为数字 n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cancelNum(Button b) &#123;</span><br><span class="line">    // 输入一个方格，将该方格上的数字撤销</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要在框架对应的位置加上对应的操作，即可将算法做选择、撤销选择的过程完全展示出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = r; i &lt; m; i++)</span><br><span class="line">    <span class="keyword">for</span> (int j = c; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">for</span> (char ch = <span class="string">&#x27;1&#x27;</span>; ch &lt;= <span class="string">&#x27;9&#x27;</span>; ch++) &#123;</span><br><span class="line">            Button b = new Button(r, c);</span><br><span class="line">            // 做选择</span><br><span class="line">            setNum(b, ch);</span><br><span class="line">            board[i][j] = ch;</span><br><span class="line">            // 继续穷举下一个</span><br><span class="line">            backtrack(board, i, j + <span class="number">1</span>)</span><br><span class="line">            // 撤销选择</span><br><span class="line">            cancelNum(b);</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、合法括号生成"><a href="#四、合法括号生成" class="headerlink" title="四、合法括号生成"></a>四、合法括号生成</h3><p>有关括号问题，记住两个性质：</p>
<p>1、一个【合法】括号组合的左括号数量一定等于右括号数量。</p>
<p>2、对于一个【合法】的括号字符串组合p，必然对于任何0&lt;=i&lt;=len（p）都有：子串p【0…i】中左括号的数量都大于或等于有括号的数量</p>
<p>输入一个整数n，计算n对括号能组成几种合法的括号组合，可以改写成：</p>
<p>现在有2n个位置，每个位置可以放置字符，组成的所有括号组合里，有多少是合法的？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(int n, int i, string&amp; track) &#123;</span><br><span class="line">    // i 代表当前的位置，共 <span class="number">2</span>n 个位置</span><br><span class="line">    // 穷举到最后一个位置了，得到一个长度为 <span class="number">2</span>n 组合</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span> * n) &#123;</span><br><span class="line">        print(track);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对于每个位置可以是左括号或者右括号两种选择</span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>] &#123;</span><br><span class="line">        track.push(choice); // 做选择</span><br><span class="line">        // 穷举下一个位置</span><br><span class="line">        backtrack(n, i + <span class="number">1</span>, track);</span><br><span class="line">        track.pop(choice); // 撤销选择</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何筛选出合法括号组合呢？</p>
<p>对于2n个位置，必然有n个左括号，n个右括号，所以我们不是简单的记录位置i，而是用left记录还可以使用多少个左括号，用right记录还可以使用多少个右括号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    // 记录所有合法的括号组合</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    // 回溯过程中的路径</span><br><span class="line">    string track;</span><br><span class="line">    // 可用的左括号和右括号数量初始化为 n</span><br><span class="line">    backtrack(n, n, track, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个</span><br><span class="line">void backtrack(int left, int right, </span><br><span class="line">            string&amp; track, vector&lt;string&gt;&amp; res) &#123;</span><br><span class="line">    // 若左括号剩下的多，说明不合法</span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) <span class="keyword">return</span>;</span><br><span class="line">    // 数量小于 <span class="number">0</span> 肯定是不合法的</span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    // 当所有括号都恰好用完时，得到一个合法的括号组合</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        res.push_back(track);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 尝试放一个左括号</span><br><span class="line">    track.push_back(<span class="string">&#x27;(&#x27;</span>); // 选择</span><br><span class="line">    backtrack(left - <span class="number">1</span>, right, track, res);</span><br><span class="line">    track.pop_back(); // 撤消选择</span><br><span class="line"></span><br><span class="line">    // 尝试放一个右括号</span><br><span class="line">    track.push_back(<span class="string">&#x27;)&#x27;</span>); // 选择</span><br><span class="line">    backtrack(left, right - <span class="number">1</span>, track, res);</span><br><span class="line">    track.pop_back(); ；// 撤消选择</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**对于递归相关的算法，时间复杂度这样计算[递归次数]x[递归函数本身的时间复杂度]**。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ltt1998.github.io/2020/12/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" data-id="ckm3606wp000q3gtqbsbrc88w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/17/%E4%BA%8C%E5%8F%89%E6%A0%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          二叉树
        
      </div>
    </a>
  
  
    <a href="/2020/12/17/%E5%9B%A2%E7%81%ADleetcode%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">团灭leetcode股票买卖问题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/12/Java%E9%9B%86%E5%90%88/">Java集合</a>
          </li>
        
          <li>
            <a href="/2021/02/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a>
          </li>
        
          <li>
            <a href="/2021/02/08/%E5%AD%90%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98/">子序列类型问题</a>
          </li>
        
          <li>
            <a href="/2021/02/05/SpringCloud/">SpringCloud</a>
          </li>
        
          <li>
            <a href="/2021/01/29/JVM/">JVM</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>